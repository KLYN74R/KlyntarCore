/**
 * 
 * 
 *                                                            * .           ..         .           .       .           .           .
 *                                                                 .         .            .          .       .
 *                                                                       .         ..xxxxxxxxxx....               .       .             .
 *                                                               .             MWMWMWWMWMWMWMWMWMWMWMWMW                       .
 *                                                                         IIIIMWMWMWMWMWMWMWMWMWMWMWMWMWMttii:        .           .
 *                                                            .      IIYVVXMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWxx...         .           .
 *                                                                IWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMx..
 *                                                              IIWMWMWMWMWMWMWMWMWBY%ZACH%AND%OWENMWMWMWMWMWMWMWMWMWMWMWMWMx..        .
 *                                                               ""MWMWMWMWMWM"""""""".  .:..   ."""""MWMWMWMWMWMWMWMWMWMWMWMWMWti.
 *                                                            .     ""   . `  .: . :. : .  . :.  .  . . .  """"MWMWMWMWMWMWMWMWMWMWMWMWMti=
 *                                                                   . .   :` . :   .  .'.' '....xxxxx...,'. '   ' ."""YWMWMWMWMWMWMWMWMWMW+
 *                                                                ; . ` .  . : . .' :  . ..XXXXXXXXXXXXXXXXXXXXx.    `     . "YWMWMWMWMWMWMW
 *                                                           .    .  .  .    . .   .  ..XXXXXXXXWWWWWWWWWWWWWWWWXXXX.  .     .     """""""
 *                                                                   ' :  : . : .  ...XXXXXWWW"   W88N88@888888WWWWWXX.   .   .       . .
 *                                                              . ' .    . :   ...XXXXXXWWW"    M88N88GGGGGG888^8M "WMBX.          .   ..  :
 *                                                                    :     ..XXXXXXXXWWW"     M88888WWRWWWMW8oo88M   WWMX.     .    :    .
 *                                                                      "XXXXXXXXXXXXWW"       WN8888WWWWW  W8@@@8M    BMBRX.         .  : :
 *                                                             .       XXXXXXXX=MMWW":  .      W8N888WWWWWWWW88888W      XRBRXX.  .       .
 *                                                                ....  ""XXXXXMM::::. .        W8@889WWWWWM8@8N8W      . . :RRXx.    .
 *                                                                    ``...'''  MMM::.:.  .      W888N89999888@8W      . . ::::"RXV    .  :
 *                                                            .       ..'''''      MMMm::.  .      WW888N88888WW     .  . mmMMMMMRXx
 *                                                                 ..' .            ""MMmm .  .       WWWWWWW   . :. :,miMM"""  : ""`    .
 *                                                              .                .       ""MMMMmm . .  .  .   ._,mMMMM"""  :  ' .  :
 *                                                                          .                  ""MMMMMMMMMMMMM""" .  : . '   .        .
 *                                                                     .              .     .    .                      .         .
 *                                                           .                                         .          .         .
 *           
 * 
 * ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸ğŸ‘ï¸â€ğŸ—¨ï¸                                                
 *
 * LINKS:[
 * 
 *         https://web3js.readthedocs.io/en/v1.2.0/web3-eth-contract.html#id36
 *         https://ethereum.stackexchange.com/questions/35997/how-to-listen-to-events-using-web3-v1-0/49472
 *         https://ethereumdev.io/listening-to-new-transactions-happening-on-the-blockchain/
 *  
 * ] 
 * 
 *                                       IMPLEMENTATION OF MONITOR FOR EVM PACK_0(via events by EVM when we push a checkpoint to some chain)
 * 
 */


/*


!MANIFEST OPTIONS:

    ?CONTRACT:"0x77D4e0dc185409B9f20f58127146692A81272799" - address of contract to grab VM logs


!REQUIRED OPTIONS TO USE MONITOR:

    ?URL:"http://youhostchainnode:<port>", - URL for node which accept RPC, API calls to query data. It might be your own node, NaaS service, "trusted" gateway, your own gateway which take info from several sources and so on

        * in some cases, URL will require some API token or smth like that. Use HTTPS only

    ?MODE:"PARANOIC" | "TRUST" - behavior for monitor. PARANOIC - you'll track hostchains on your own, block by block to make sure everything is ok. TRUST - you just ask another "trusted" instance about checkpoints

    ?CONTRACT - address of contract to track

    ?ABI - JSON'ed ABI of contract

    ?FIRST_BLOCK_FIND_STEP - step to find first block of the day


    The following options must be in section MONITORING_PRESET

        ?START_FROM - height to start to monitor from

*/




import {GET_ALL_KNOWN_PEERS,GET_MAJORITY, BLS_VERIFY, CHECK_IF_THE_SAME_DAY} from '../../../KLY_Workflows/dev_tachyon/utils.js'

import bls from '../../../KLY_Utils/signatures/multisig/bls.js'

import {BLAKE3,LOG} from '../../../KLY_Utils/utils.js'

import fetch from 'node-fetch'

import Web3 from 'web3'




//Make it global
let web3=new Web3(CONFIG.SYMBIOTE.MONITOR.URL),

//Get the requiered stuff from configs
{ABI,CONTRACT,TICKER} = CONFIG.SYMBIOTE.MONITOR,

//Create the contract instance
contractInstance = new web3.eth.Contract(ABI,CONTRACT),




//threadID - VERIFICATION_THREAD | QUORUM_THREAD

GET_CONTRACT_EVENTS_RANGE=async threadID=>{

    /*
    
        SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER - <index of array events not to start from 0 each time>
        SYMBIOTE_META[threadID].CHECKPOINT.RANGE_FINISH_BLOCK - <id of the latest block in range>
    
    */


    let isInitialLoad = SYMBIOTE_META[threadID].CHECKPOINT.RANGE_FINISH_BLOCK === SYMBIOTE_META[threadID].CHECKPOINT.RANGE_START_BLOCK,

        nextRangeStartsFrom = isInitialLoad ? CONFIG.SYMBIOTE.MONITOR.MONITORING_START_FROM : SYMBIOTE_META[threadID].CHECKPOINT.RANGE_FINISH_BLOCK+1,

        wasLatestRangeEmpty = SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER === -1,

        weFinishedToEnumThisRange = SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER === SYMBIOTE_META[threadID+'_EVENTS'].length && SYMBIOTE_META[threadID+'_EVENTS'].length !==0



    if(weFinishedToEnumThisRange || isInitialLoad || wasLatestRangeEmpty){

        // We should find next range if no more range exists locally
        // Otherwise - get the range from local storage and add to cache
        console.log(`[${threadID}] HERE because`)

        console.log(weFinishedToEnumThisRange)
        console.log(isInitialLoad)
        console.log(wasLatestRangeEmpty)

        console.log('ID is ',nextRangeStartsFrom+`_${threadID}_EVENTS`)

        let range = await SYMBIOTE_META.HOSTCHAIN_DATA.get(nextRangeStartsFrom+`_${threadID}_EVENTS`).catch(_=>false)

        if(range){

            console.log(`[${threadID}] RANGE WAS IN DB`)
            
            SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER=0 //reset the counter to the start of array

            SYMBIOTE_META[threadID].CHECKPOINT.RANGE_START_BLOCK=nextRangeStartsFrom

            SYMBIOTE_META[threadID].CHECKPOINT.RANGE_FINISH_BLOCK=range.latestBlockInRange

            SYMBIOTE_META[threadID+'_EVENTS']=range.events

            return SYMBIOTE_META[threadID+'_EVENTS']

        }else{

            //Otherwise - query next range

            console.log(`[${threadID}] Going to query`)
            
            let lastKnownBlockNumber = await web3.eth.getBlockNumber().catch(error=>{

                    LOG(`Some error occured with hostchain node => \x1b[32;1m${error}`,'W')

                    return false

                })

    
            if(lastKnownBlockNumber){

                LOG(`Found new latest known block on hostchain [\x1b[33;1m${TICKER}\x1b[36;1m] => \x1b[32;1m${lastKnownBlockNumber}`,'I')

                //Get from the height we stopped till the last known block
        
                let options = {
    
                    fromBlock:nextRangeStartsFrom,

                    toBlock:lastKnownBlockNumber
    
                };

                console.log(`[${threadID}] Going to ask `,options)

                //If node works too fast - we shoudn't ask blocks from X+1 to X (coz X<Z+1)
                if(nextRangeStartsFrom>=lastKnownBlockNumber) return
            
                let events = await contractInstance.getPastEvents('Checkpoint',options).catch(error=>{

                    LOG(`Received this error when asking for events => ${error}`,'W')

                    return false

                })

    
                if(Array.isArray(events)){

                    if(events.length){

                        //Update thread data and store locally not to make requests too frequently

                        let range={
                        
                            events,

                            latestBlockInRange:lastKnownBlockNumber

                        }

                        await SYMBIOTE_META.HOSTCHAIN_DATA.put(nextRangeStartsFrom+`_${threadID}_EVENTS`,range).catch(
                        
                            error => LOG(`Error occured when trying to store events => ${error}`)
                        
                        )

                        //TODO:And probably - delete the previous range(not to take up much space)

                    }else {

                        //If no events on range [nextRangeStartsFrom;lastKnownBlockNumber] - change the range

                        SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER=-1 // -1 means that latest received range has no events 

                        SYMBIOTE_META[threadID].CHECKPOINT.RANGE_START_BLOCK=nextRangeStartsFrom

                        SYMBIOTE_META[threadID].CHECKPOINT.RANGE_FINISH_BLOCK=lastKnownBlockNumber

                    }

                }

            }

        }

    } else {

        if(!SYMBIOTE_META[threadID+'_EVENTS']){

            SYMBIOTE_META[threadID+'_EVENTS']=await SYMBIOTE_META.HOSTCHAIN_DATA.get(SYMBIOTE_META[threadID].CHECKPOINT.RANGE_START_BLOCK+`_${threadID}_EVENTS`).catch(_=>false)

        }

        return SYMBIOTE_META[threadID+'_EVENTS']

    }
        
},




CHECK_IF_AT_LEAST_ONE_DAY_DIFFERENCE=(timestampLater,timestampEarlier)=>{

    let startOfDayLater = new Date(timestampLater*1000),

        startOfDayEarlier = new Date(timestampEarlier*1000)


    startOfDayLater.setUTCHours(0, 0, 0, 0)

    startOfDayEarlier.setUTCHours(0, 0, 0, 0)


    return startOfDayLater-startOfDayEarlier >= 86400

},




VERIFY_AND_RETURN_CHECKPOINT=async(event,currentCheckpoint,quorumNumber,majority)=>{



    if(CHECK_IF_AT_LEAST_ONE_DAY_DIFFERENCE(+event.returnValues.blocktime,currentCheckpoint.TIMESTAMP)){

        //Knowing the quorum, we can step-by-step enumerate events and find the next valid checkpoint

        let {ID,PAYLOAD_HASH,QUORUM_AGGREGATED_SIGNERS_PUBKEY,QUORUM_AGGREGATED_SIGNATURE,AFK_VALIDATORS} = JSON.parse(event.returnValues.payload)


        //_________________________ VERIFY _________________________

        console.log(currentCheckpoint)

        console.log('Checking isNEXT => ',currentCheckpoint.HEADER.ID,' => ',ID)

        //Make sure it's really next
        let isNext = currentCheckpoint.HEADER.ID+1 === ID

        //[+] Aggregated quorum pubkey ==== AGGREGATE(afkValidators,aggregatedPub)
        //[+] QUORUM_SIZE-afkValidators >= QUORUM_SIZE(2/3N+1) (majority)
        //[+] VERIFY(aggregatedPub,aggregatedSigna,hash)
        let signaIsOk = await bls.verifyThresholdSignature(QUORUM_AGGREGATED_SIGNERS_PUBKEY,AFK_VALIDATORS,SYMBIOTE_META.STATIC_STUFF_CACHE.get('QT_ROOTPUB'),PAYLOAD_HASH,QUORUM_AGGREGATED_SIGNATURE,quorumNumber-majority)

        
        if(isNext && signaIsOk) {

            let validCheckpoint = {

                HEADER:{

                    ID,

                    PAYLOAD_HASH,

                    QUORUM_AGGREGATED_SIGNERS_PUBKEY,

                    QUORUM_AGGREGATED_SIGNATURE,

                    AFK_VALIDATORS

                },

                //We'll add checkpoint payload once find it

                //Based on PAYLOAD.VALIDATORS_METADATA, we get new quorum for QUORUM_THREAD. For VERIFICATION_THREAD we get the quorum based on own verification process

                TIMESTAMP:+event.returnValues.blocktime,

                FOUND_AT_BLOCK:event.blockNumber,

                COMPLETED:false

            }

            /*
        
            Then,find pure PAYLOAD related to hash in header
        
            PAYLOAD is {

                PREV_PAYLOAD_HASH

                VALIDATORS_METADATA:{},

                OPERATIONS:{},

                OTHER_SYMBIOTES:{}

            }

            To verify: BLAKE3(JSON.stringify(PAYLOAD)) === HASH_IN_HEADER
        
            */

            let initURLs = [CONFIG.SYMBIOTE.GET_CHECKPOINT_PAYLOAD_URL,...GET_ALL_KNOWN_PEERS()]

            LOG(`Going to find body to checkpoint \x1b[34;1m${validCheckpoint.HEADER.ID} ### ${validCheckpoint.HEADER.PAYLOAD_HASH}`,'S')

            console.log(initURLs)

            //__________________________________Start the infinite loop to find the body to checkpoint__________________________________
                
            let shouldStopWhile=false

            while(true){
                
                for(let url of initURLs){

                    if(SYSTEM_SIGNAL_ACCEPTED) break
                                
                    let checkpointPayload = await fetch(url+'/get_payload_for_checkpoint/'+PAYLOAD_HASH).then(r=>r.json()).catch(_=>false)

                    if(checkpointPayload && checkpointPayload.PREV_PAYLOAD_HASH === currentCheckpoint.HEADER.PAYLOAD_HASH && BLAKE3(JSON.stringify(checkpointPayload)) === PAYLOAD_HASH){

                        validCheckpoint.PAYLOAD = checkpointPayload

                        //Change flag for outer(while) cycle
                        shouldStopWhile=true

                        //And break this <for> cycle
                        break

                    }

                }

                if(shouldStopWhile || SYSTEM_SIGNAL_ACCEPTED) break
            
            }
            
            return validCheckpoint

        }

    }

}


/*

Checkpoint structure

Header:

{
    PAYLOAD_HASH: <32 bytes BLAKE3 HASH OF CHECKPOINT PAYLOAD. Quorum sign this hash>
    
    QUORUM_AGGREGATED_SIGNERS_PUBKEY:<48 bytes BLS AGGREGATED PUBKEY OF VALIDATORS FROM CURRENT QUORUM WHO SIGNED CHECKPOINT>

    QUORUM_AGGREGATED_SIGNATURE:<96 bytes BLS AGGREGATED SIGNATURE which verified by aggregated pubkey>

    AFK_VALIDATORS:<ARRAY OF AFK VALIDATORS FROM QUORUM WHO SKIPPED CHECKPOINT GENERATION PROCEDURE.48 BYTES PER PUBKEY>

}

If QUORUM SIZE=127 and threshold is 2/3N+1 (required by typical BFT), then count the worst case - when N/3 is AFK, malicious activity or some other problem(poor connection,fault and so on)

N/3=42

Then, the biggest possible checkpoint size is:

32 - checkpoint payload hash.
+
48 - aggregated BLS pubkey of signers
+
96 - aggregated signature
+
48*42
______________________

2192 bytes - the biggest possible checkpoint size in case QUORUM SIZE=127(validators number might be infinite)


-------------------------------------------------------------Checkpoint payload-------------------------------------------------------------

Checkpoint payload contains:

OTHER_CHECKPOINTS (KEY=>VALUE) => (SYMBIOTE_ID=>CHECKPOINT_HEADER) - object with checkpoints from other symbiotes to perform Hivemind activity

VALIDATORS_METADATA - object like this

        {
            '7GPupbq1vtKUgaqVeHiDbEJcxS7sSjwPnbht4eRaDBAEJv8ZKHNCSu2Am3CuWnHjta': {
                INDEX: -1,
                HASH: 'Poyekhali!@Y.A.Gagarin'
            }
    
        }

    Key - BLS pubkey of validator
    Value - object to track progress to verify blocks step-by-step





*/

export default {

    // threadID - SYMBIOTE_META.VERIFICATION_THREAD | SYMBIOTE_META.QUORUM_THREAD
    //  QUORUM_THREAD - Receive latest valid checkpoint. If checkpoint of today includes our pubkey - then start accept blocks & share commitments due to the VALIDATORS_METADATA state in checkpoint
    /*
    
     Reminder: Checkpoint structure

        Header:

            {
                PAYLOAD_HASH: <32 bytes BLAKE3 HASH OF CHECKPOINT PAYLOAD. Quorum sign this hash>
    
                QUORUM_AGGREGATED_SIGNERS_PUBKEY:<48 bytes BLS AGGREGATED PUBKEY OF VALIDATORS FROM CURRENT QUORUM WHO SIGNED CHECKPOINT>

                QUORUM_AGGREGATED_SIGNATURE:<96 bytes BLS AGGREGATED SIGNATURE which verified by aggregated pubkey>

                AFK_VALIDATORS:<ARRAY OF AFK VALIDATORS FROM QUORUM WHO SKIPPED CHECKPOINT GENERATION PROCEDURE.48 BYTES PER PUBKEY>

            }

            
        Payload:

            {

                PREV_CHECKPOINT_PAYLOAD_HASH

                VALIDATORS_METADATA:{
                
                    VALIDATOR_0 : {INDEX:number,HASH:string},

                    VALIDATOR_1 : {INDEX:number,HASH:string},

                    ...

                    VALIDATOR_N : {INDEX:number,HASH:string}
                
                }

                OPERATIONS:{

                    Here we add/remove validators, assign to validators and so on

                }

                
                OTHER_SYMBIOTES:{

                    SYMBIOTE_ID_X: CHECKPOINTS_HEADERS_OF_OTHER_SYMBIOTES,

                    SYMBIOTE_ID_Y: CHECKPOINTS_HEADERS_OF_OTHER_SYMBIOTES,

                    ...

                }

            }

        Timestamp:number(we set the timestamp from hostchains to track days changes)

        Completed:bool(required by VERIFICATION_THREAD)



        **************************************************************************************************************

        In checkpoint on hostchain(no matter what hostchain you use) we receive raw version of checkpoint in hexademical format

        First 32 bytes - checkpoint payload hash

        Next 48 bytes - aggregated BLS pubkey of signers(it should be 2/3N+1 of current quorum)

        Next 96 bytes - aggregated signature

        The rest - splitted for 48 bytes BLS pubkeys of members whose signatures we hadn't get(due to network issues or order in cycle)


        => { hash, aggregatedPub, aggregatedSigna, afkValidators }
        
        ***************************************************************************************************************

        To verify checkpoint is valid(so we can accept it and continue verification thread):

            [+] Aggregated quorum pubkey ==== AGGREGATE(afkValidators,aggregatedPub)

            [+] QUORUM_SIZE-afkValidators >= QUORUM_SIZE(2/3N+1)

            [+] VERIFY(aggregatedPub,aggregatedSigna,hash)


    
    */
    
    GET_VALID_CHECKPOINT:async threadID => {


        let currentCheckpoint = SYMBIOTE_META[threadID].CHECKPOINT,

            quorumNumber=SYMBIOTE_META[threadID].CHECKPOINT.QUORUM.length,

            majority = GET_MAJORITY(threadID)


        //Find next checkpoint and verify signatures

        let eventsRange = await GET_CONTRACT_EVENTS_RANGE(threadID)


        if(eventsRange){

            console.log('Received events ',eventsRange)
        
            //Start array with SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER(pointer to position in range not to start from 0 position each time)

            let possibleValidCheckpoint,

                startFrom = SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER
            
            console.log('Range pointer ',startFrom)

            //Start to enumerate the range of events, starting from position <startFrom>
            
            for(let index in eventsRange){

                if(index<startFrom) continue

                else{

                    possibleValidCheckpoint = await VERIFY_AND_RETURN_CHECKPOINT(eventsRange[index],currentCheckpoint,quorumNumber,majority).catch(_=>false)

                    //We do break here, because valid checkpoint was found or system signal accepted
                    if(possibleValidCheckpoint?.PAYLOAD||SYSTEM_SIGNAL_ACCEPTED) break

                    //If log is not a checkpoint - just increase counter for progress
                    else SYMBIOTE_META[threadID].CHECKPOINT.RANGE_POINTER++

    
                }

            }

            if(possibleValidCheckpoint?.PAYLOAD) return possibleValidCheckpoint 

        }

    },




    //This function gets the information from hostchain and if it's a new day - we can start proposing the checkpoint
    CHECK_IF_ITS_TIME_TO_PROPOSE_CHECKPOINT:async()=>{

        let latestKnownBlock = await web3.eth.getBlockNumber().catch(_=>false)

        if(latestKnownBlock){

            // We should take previous blocks to make sure that new day has started

            let severalBlocksAgo = CONFIG.SYMBIOTE.MONITOR.BLOCK_STOCK_TO_PROPOSE_CHECKPOINT,

                block = await web3.eth.getBlock(latestKnownBlock-severalBlocksAgo).catch(_=>false)


            if(block){

                return CHECK_IF_AT_LEAST_ONE_DAY_DIFFERENCE(SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT.TIMESTAMP,+block.timestamp)

            }

        }

    },




    GET_SKIP_PROCEDURE_STAGE_1_PROOFS:async()=>{

        /*
        
        [+] Call this function periodically to find the proofs of SKIP_PROCEDURE_STAGE_1 on hostchain
        [+] Once find, verify it. The structure of proof that 2/3N+1 have voted to exclude some subchain

        {
            session:'0123456701234567012345670123456701234567012345670123456701234567',
            subchain:'7dNmJLXWf2UUDK5S5KdTKWMoGaG3teqSgGz5oGN3q33eRP1erTZB6QaV8ifJvmoV3X',
            
            sig:<signature by initiator to proof that "YES,I've grabbed this agreements and we(the quorum majority) is really want to exclude this subchain from verification process". SIG(session+session)>
            initiator:<Your pubkey to verify this signature>

            aggregatedPub:'7fJo5sUy3pQBaFrVGHyQA2Nqz2APpd7ZBzvoXSHWTid5CJcqskQuc428fkWqunDuDu',
            aggregatedSigna:SIG('SKIP_STAGE_1'+session+requestedSubchain+initiator),
            afk:[<array of afk from quorum>]
        }

        [+] To verify => verify aggregated signature by quorum majority and initiator's signature
        [+] Add subchain to SYMBIOTE_META.SKIP_PROCEDURE_STAGE_1 set to response with the proofs for stage 2
        
        */


        let lastKnownBlockNumber = await web3.eth.getBlockNumber().catch(error=>{

            LOG(`Some error occured with hostchain node => \x1b[32;1m${error}`,'W')

            return false

        })


        if(lastKnownBlockNumber){

            //Get from the height we stopped till the last known block

            global.SKIP_PROCEDURE_STAGE_1_BLOCK ||= SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT.FOUND_AT_BLOCK

            let options = {

                fromBlock:global.SKIP_PROCEDURE_STAGE_1_BLOCK,

                toBlock:lastKnownBlockNumber

            };


            //If node works too fast - we shoudn't ask blocks from X+1 to X (coz X<Z+1)
            if(options.fromBlock>=lastKnownBlockNumber) return
            

            let events = await contractInstance.getPastEvents('SkipProcedure',options).catch(error=>{

                LOG(`Received this error when asking for events => ${error}`,'W')

                return false

            })


            if(events.length){

                global.SKIP_PROCEDURE_STAGE_1_BLOCK=options.toBlock                

                // Parse & verify logs here. Everything what will be found will be assumed that relate to the checkpoint

                let currentCheckpoint = {...SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT}
                
                
                let currentCheckpointID = currentCheckpoint.HEADER.ID

                let currentCheckpointPayloadHash = currentCheckpoint.HEADER.PAYLOAD_HASH

                let checkpointFullID = currentCheckpointPayloadHash+currentCheckpointID

                let currentCheckpointTimestamp = currentCheckpoint.TIMESTAMP


                let reverseThreshold = SYMBIOTE_META.QUORUM_THREAD.WORKFLOW_OPTIONS.QUORUM_SIZE-GET_MAJORITY('QUORUM_THREAD')

                let rootPub = SYMBIOTE_META.STATIC_STUFF_CACHE.get('QT_ROOTPUB')


                currentCheckpointTimestamp*=1000


                for(let event of events){

                    let {session,subchain,sig,initiator,aggregatedPub,aggregatedSignature,afkValidators} = JSON.parse(event.returnValues.payload)

                    let majorityVotedForIt = await bls.verifyThresholdSignature(aggregatedPub,afkValidators,rootPub,'SKIP_STAGE_1'+session+subchain+initiator+checkpointFullID,aggregatedSignature,reverseThreshold)
                    
                    let initiatorSigIsOk = await BLS_VERIFY(session+session,sig,initiator)

                    let isTheSameDay = CHECK_IF_THE_SAME_DAY(currentCheckpointTimestamp,(+event.returnValues.blocktime)*1000)



                    if(majorityVotedForIt && initiatorSigIsOk && isTheSameDay){

                        let setOfSubchainsToSkipForCurrentCheckpoint = SYMBIOTE_META.ASYNC_HELPER_FOR_SKIP_PROCEDURE_STAGE_1.get(checkpointFullID)

                        setOfSubchainsToSkipForCurrentCheckpoint.add(subchain)

                    }

                }
                
            }
    
        }

    },
    



    GET_SKIP_PROCEDURE_STAGE_2_PROOFS:async()=>{

        /*
        
            [+] Call this function periodically to find the proofs of SKIP_PROCEDURE_STAGE_2 on hostchain
            [+] This proof means that majority is going to exclude the subchain from verification thread. It contains the height/hash of the latest known segment of subchain
            [+] During the work in function START_VERIFICATION_THREAD, we'll use this proof to skip appropriate subchain on appropriate height
            [+] Format is

            {
                subchain:'<pubkey of subchain that we're going to skip>,
                index:<latest block index that majority have voted for, but we can't get the index+1 block, that's why-skip>
                hash:<hash of appropriate block>
                
                aggregatedPub:'7fJo5sUy3pQBaFrVGHyQA2Nqz2APpd7ZBzvoXSHWTid5CJcqskQuc428fkWqunDuDu',
                aggregatedSigna:SIG(`SKIP_STAGE_2:<SUBCHAIN>:<INDEX>:<HASH>:<QT.CHECKPOINT.HEADER.PAYLOAD_HASH>:<QT.CHECKPOINT.HEADER.ID>`)
                afk:[]
            }

            [+] Note that this is valid only in case that index is bigger that we have in SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT.PAYLOAD.VALIDATORS_METADATA[subchain].
                For this reasons, subchain will be deactivated at least untill the next checkpoint.
                Also, it should has a valid timestamp(today) to make sure it's between <CURRENT_CHECKPOINT> <=> <NEXT_CHECKPOINT>
            
        */


        
        let lastKnownBlockNumber = await web3.eth.getBlockNumber().catch(error=>{

            LOG(`Some error occured with hostchain node => \x1b[32;1m${error}`,'W')

            return false

        })


        if(lastKnownBlockNumber){

            //Get from the height we stopped till the last known block

            global.SKIP_PROCEDURE_STAGE_2_BLOCK ||= SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT.FOUND_AT_BLOCK

            let options = {

                fromBlock:global.SKIP_PROCEDURE_STAGE_2_BLOCK,

                toBlock:lastKnownBlockNumber

            };


            //If node works too fast - we shoudn't ask blocks from X+1 to X (coz X<Z+1)
            if(options.fromBlock>=lastKnownBlockNumber) return
            
            let events = await contractInstance.getPastEvents('SkipProcedure',options).catch(error=>{

                LOG(`Received this error when asking for events => ${error}`,'W')

                return false

            })


            if(events.length){

                global.SKIP_PROCEDURE_STAGE_2_BLOCK=options.toBlock

                // Parse & verify logs here. Everything what will be found will be assumed that relate to the checkpoint

                let currentCheckpoint = {...SYMBIOTE_META.QUORUM_THREAD.CHECKPOINT}

                
                let currentCheckpointIndex = currentCheckpoint.HEADER.ID

                let currentCheckpointPayloadHash = currentCheckpoint.HEADER.PAYLOAD_HASH

                let checkpointFullID = currentCheckpointPayloadHash+currentCheckpointIndex

                let currentCheckpointTimestamp = currentCheckpoint.TIMESTAMP

                let reverseThreshold = SYMBIOTE_META.QUORUM_THREAD.WORKFLOW_OPTIONS.QUORUM_SIZE-GET_MAJORITY('QUORUM_THREAD')

                let rootPub = SYMBIOTE_META.STATIC_STUFF_CACHE.get('QT_ROOTPUB')


                currentCheckpointTimestamp*=1000


                for(let event of events){

                    let {subchain,index,hash,aggregatedPub,aggregatedSignature,afkValidators} = JSON.parse(event.returnValues.payload)

                    let majorityVotedForIt = await bls.verifyThresholdSignature(aggregatedPub,afkValidators,rootPub,`SKIP_STAGE_2:${subchain}:${index}:${hash}:${currentCheckpointPayloadHash}:${currentCheckpointIndex}`,aggregatedSignature,reverseThreshold)

                    let isTheSameDay = CHECK_IF_THE_SAME_DAY(currentCheckpointTimestamp,(+event.returnValues.blocktime)*1000)


                    
                    if(majorityVotedForIt && isTheSameDay){

                        let mapOfSubchainsToSkipForCurrentCheckpoint = SYMBIOTE_META.SKIP_PROCEDURE_STAGE_2.get(checkpointFullID)

                        // We'll need it inside START_VERIFICATION_THREAD function to know which blocks we should skip
                        mapOfSubchainsToSkipForCurrentCheckpoint.set(subchain,{INDEX:index,HASH:hash})

                    }

                }
                
            }
    
        }

    }

}